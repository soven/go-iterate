// Code generated by github.com/soven/go-iterate. DO NOT EDIT.
package iter

import "github.com/pkg/errors"

type Int16Checker interface {
	// It is suggested to return EndOfInt16Iterator to stop iteration.
	Check(int16) (bool, error)
}

type Int16Check func(int16) (bool, error)

func (ch Int16Check) Check(item int16) (bool, error) { return ch(item) }

var (
	AlwaysInt16CheckTrue  = Int16Check(func(item int16) (bool, error) { return true, nil })
	AlwaysInt16CheckFalse = Int16Check(func(item int16) (bool, error) { return false, nil })
)

func NotInt16(checker Int16Checker) Int16Checker {
	if checker == nil {
		return AlwaysInt16CheckTrue
	}
	return Int16Check(func(item int16) (bool, error) {
		yes, err := checker.Check(item)
		if err != nil {
			// No error wrapping since an error context is missing.
			return false, err
		}

		return !yes, nil
	})
}

type andInt16 struct {
	lhs, rhs Int16Checker
}

func (a andInt16) Check(item int16) (bool, error) {
	isLHSPassed, err := a.lhs.Check(item)
	if err != nil {
		return false, wrapIfNotEndOfInt16Iterator(err, "lhs check")
	}
	if !isLHSPassed {
		return false, nil
	}

	isRHSPassed, err := a.rhs.Check(item)
	if err != nil {
		return false, wrapIfNotEndOfInt16Iterator(err, "rhs check")
	}
	return isRHSPassed, nil
}

func AllInt16(checkers ...Int16Checker) Int16Checker {
	var all Int16Checker = AlwaysInt16CheckTrue
	for i := len(checkers) - 1; i >= 0; i-- {
		if checkers[i] == nil {
			continue
		}
		all = andInt16{checkers[i], all}
	}
	return all
}

type orInt16 struct {
	lhs, rhs Int16Checker
}

func (o orInt16) Check(item int16) (bool, error) {
	isLHSPassed, err := o.lhs.Check(item)
	if err != nil {
		return false, wrapIfNotEndOfInt16Iterator(err, "lhs check")
	}
	if isLHSPassed {
		return true, nil
	}

	isRHSPassed, err := o.rhs.Check(item)
	if err != nil {
		return false, wrapIfNotEndOfInt16Iterator(err, "rhs check")
	}
	return isRHSPassed, nil
}

func AnyInt16(checkers ...Int16Checker) Int16Checker {
	var any Int16Checker = AlwaysInt16CheckFalse
	for i := len(checkers) - 1; i >= 0; i-- {
		if checkers[i] == nil {
			continue
		}
		any = orInt16{checkers[i], any}
	}
	return any
}

type FilteringInt16Iterator struct {
	preparedInt16Item
	filter Int16Checker
}

func (it *FilteringInt16Iterator) HasNext() bool {
	if it.hasNext {
		return true
	}
	for it.preparedInt16Item.HasNext() {
		next := it.base.Next()
		isFilterPassed, err := it.filter.Check(next)
		if err != nil {
			if !isEndOfInt16Iterator(err) {
				err = errors.Wrap(err, "filtering iterator: check")
			}
			it.err = err
			return false
		}

		if !isFilterPassed {
			continue
		}

		it.hasNext = true
		it.next = next
		return true
	}

	return false
}

// Int16Filtering sets filter while iterating over items.
// If filters is empty, so all items will return.
func Int16Filtering(items Int16Iterator, filters ...Int16Checker) Int16Iterator {
	if items == nil {
		return EmptyInt16Iterator
	}
	return &FilteringInt16Iterator{preparedInt16Item{base: items}, AllInt16(filters...)}
}

func Int16Filter(items Int16Iterator, checker ...Int16Checker) error {
	// no error wrapping since no additional context for the error; just return it.
	return Int16Discard(Int16Filtering(items, checker...))
}

type Int16EnumChecker interface {
	// It is suggested to return EndOfInt16Iterator to stop iteration.
	Check(int, int16) (bool, error)
}

type Int16EnumCheck func(int, int16) (bool, error)

func (ch Int16EnumCheck) Check(n int, item int16) (bool, error) { return ch(n, item) }

type enumFromInt16Checker struct {
	Int16Checker
}

func (ch enumFromInt16Checker) Check(_ int, item int16) (bool, error) {
	return ch.Int16Checker.Check(item)
}

func EnumFromInt16Checker(checker Int16Checker) Int16EnumChecker {
	return &enumFromInt16Checker{checker}
}

var (
	AlwaysInt16EnumCheckTrue  = EnumFromInt16Checker(AlwaysInt16CheckTrue)
	AlwaysInt16EnumCheckFalse = EnumFromInt16Checker(AlwaysInt16CheckFalse)
)

func EnumNotInt16(checker Int16EnumChecker) Int16EnumChecker {
	if checker == nil {
		return AlwaysInt16EnumCheckTrue
	}
	return Int16EnumCheck(func(n int, item int16) (bool, error) {
		yes, err := checker.Check(n, item)
		if err != nil {
			// No error wrapping since an error context is missing.
			return false, err
		}

		return !yes, nil
	})
}

type enumAndInt16 struct {
	lhs, rhs Int16EnumChecker
}

func (a enumAndInt16) Check(n int, item int16) (bool, error) {
	isLHSPassed, err := a.lhs.Check(n, item)
	if err != nil {
		return false, wrapIfNotEndOfInt16Iterator(err, "lhs check")
	}
	if !isLHSPassed {
		return false, nil
	}

	isRHSPassed, err := a.rhs.Check(n, item)
	if err != nil {
		return false, wrapIfNotEndOfInt16Iterator(err, "rhs check")
	}
	return isRHSPassed, nil
}

func EnumAllInt16(checkers ...Int16EnumChecker) Int16EnumChecker {
	var all Int16EnumChecker = AlwaysInt16EnumCheckTrue
	for i := len(checkers) - 1; i >= 0; i-- {
		if checkers[i] == nil {
			continue
		}
		all = enumAndInt16{checkers[i], all}
	}
	return all
}

type enumOrInt16 struct {
	lhs, rhs Int16EnumChecker
}

func (o enumOrInt16) Check(n int, item int16) (bool, error) {
	isLHSPassed, err := o.lhs.Check(n, item)
	if err != nil {
		return false, wrapIfNotEndOfInt16Iterator(err, "lhs check")
	}
	if isLHSPassed {
		return true, nil
	}

	isRHSPassed, err := o.rhs.Check(n, item)
	if err != nil {
		return false, wrapIfNotEndOfInt16Iterator(err, "rhs check")
	}
	return isRHSPassed, nil
}

func EnumAnyInt16(checkers ...Int16EnumChecker) Int16EnumChecker {
	var any Int16EnumChecker = AlwaysInt16EnumCheckFalse
	for i := len(checkers) - 1; i >= 0; i-- {
		if checkers[i] == nil {
			continue
		}
		any = enumOrInt16{checkers[i], any}
	}
	return any
}

type EnumFilteringInt16Iterator struct {
	preparedInt16Item
	filter Int16EnumChecker
	count  int
}

func (it *EnumFilteringInt16Iterator) HasNext() bool {
	if it.hasNext {
		return true
	}
	for it.preparedInt16Item.HasNext() {
		next := it.base.Next()
		isFilterPassed, err := it.filter.Check(it.count, next)
		if err != nil {
			if !isEndOfInt16Iterator(err) {
				err = errors.Wrap(err, "enum filtering iterator: check")
			}
			it.err = err
			return false
		}
		it.count++

		if !isFilterPassed {
			continue
		}

		it.hasNext = true
		it.next = next
		return true
	}

	return false
}

// Int16EnumFiltering sets filter while iterating over items and their serial numbers.
// If filters is empty, so all items will return.
func Int16EnumFiltering(items Int16Iterator, filters ...Int16EnumChecker) Int16Iterator {
	if items == nil {
		return EmptyInt16Iterator
	}
	return &EnumFilteringInt16Iterator{preparedInt16Item{base: items}, EnumAllInt16(filters...), 0}
}

type DoingUntilInt16Iterator struct {
	preparedInt16Item
	until Int16Checker
}

func (it *DoingUntilInt16Iterator) HasNext() bool {
	if it.hasNext {
		return true
	}
	for it.preparedInt16Item.HasNext() {
		next := it.base.Next()
		isUntilPassed, err := it.until.Check(next)
		if err != nil {
			if !isEndOfInt16Iterator(err) {
				err = errors.Wrap(err, "doing until iterator: until")
			}
			it.err = err
			return false
		}

		if isUntilPassed {
			it.err = EndOfInt16Iterator
		}

		it.hasNext = true
		it.next = next
		return true
	}

	return false
}

// Int16DoingUntil sets until checker while iterating over items.
// If untilList is empty, so all items returned as is.
func Int16DoingUntil(items Int16Iterator, untilList ...Int16Checker) Int16Iterator {
	if items == nil {
		return EmptyInt16Iterator
	}
	return &DoingUntilInt16Iterator{preparedInt16Item{base: items}, AllInt16(untilList...)}
}

func Int16DoUntil(items Int16Iterator, untilList ...Int16Checker) error {
	// no error wrapping since no additional context for the error; just return it.
	return Int16Discard(Int16DoingUntil(items, untilList...))
}

// Int16GettingBatch returns the next batch from items.
func Int16GettingBatch(items Int16Iterator, batchSize int) Int16Iterator {
	if items == nil {
		return EmptyInt16Iterator
	}
	if batchSize == 0 {
		return items
	}

	size := 0
	return Int16DoingUntil(items, Int16Check(func(item int16) (bool, error) {
		size++
		return size >= batchSize, nil
	}))
}
