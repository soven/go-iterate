package {{ .PackageName }}

// {{ .TitlePrefix }}Iterator is an iterator over items type of {{ .TypeName }}.
type {{ .TitlePrefix }}Iterator interface {
	// HasNext checks if there is the next item
	// in the iterator. HasNext should be idempotent.
	HasNext() bool
	// Next should return next item in the iterator.
	// It should be invoked after check HasNext.
	Next() {{ .TypeName }}
	// Err contains first met error while Next.
	Err() error
}

type empty{{ .TitlePrefix }}Iterator struct{}

func (empty{{ .TitlePrefix }}Iterator) HasNext() bool     { return false }
func (empty{{ .TitlePrefix }}Iterator) Next() (next {{ .TypeName }}) { return {{ .ZeroTypeValue }} }
func (empty{{ .TitlePrefix }}Iterator) Err() error        { return nil }

// Empty{{ .TitlePrefix }}Iterator is a zero value for {{ .TitlePrefix }}Iterator.
// It is not contains any item to iterate over it.
var Empty{{ .TitlePrefix }}Iterator {{ .TitlePrefix }}Iterator = empty{{ .TitlePrefix }}Iterator{}

// {{ .TitlePrefix }}IterMaker is a maker of {{ .TitlePrefix }}Iterator.
type {{ .TitlePrefix }}IterMaker interface {
	// MakeIter should return a new instance of {{ .TitlePrefix }}Iterator to iterate over it.
	MakeIter() {{ .TitlePrefix }}Iterator
}

// Make{{ .TitlePrefix }}Iter is a shortcut implementation
// of {{ .TitlePrefix }}Iterator based on a function.
type Make{{ .TitlePrefix }}Iter func() {{ .TitlePrefix }}Iterator

// MakeIter returns a new instance of {{ .TitlePrefix }}Iterator to iterate over it.
func (m Make{{ .TitlePrefix }}Iter) MakeIter() {{ .TitlePrefix }}Iterator { return m() }

// MakeNo{{ .TitlePrefix }}Iter is a zero value for {{ .TitlePrefix }}IterMaker.
// It always returns Empty{{ .TitlePrefix }}Iterator and an empty error.
var MakeNo{{ .TitlePrefix }}Iter {{ .TitlePrefix }}IterMaker = Make{{ .TitlePrefix }}Iter(
	func() {{ .TitlePrefix }}Iterator { return Empty{{ .TitlePrefix }}Iterator })

// {{ .TitlePrefix }}Discard just range over all items and do nothing with each of them.
func {{ .TitlePrefix }}Discard(items {{ .TitlePrefix }}Iterator) error {
	if items == nil {
		items = Empty{{ .TitlePrefix }}Iterator
	}
	for items.HasNext() {
		_ = items.Next()
	}
	// no error wrapping since no additional context for the error; just return it.
	return items.Err()
}
