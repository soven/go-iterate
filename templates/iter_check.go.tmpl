// Code generated by github.com/soven/go-iterate. DO NOT EDIT.
package {{ .PackageName }}

import "github.com/pkg/errors"

// {{ .TitlePrefix }}Checker is an object checking an item type of {{ .TypeName }}
// for some condition.
type {{ .TitlePrefix }}Checker interface {
	// Check should check an item type of {{ .TypeName }} for some condition.
	// It is suggested to return EndOf{{ .TitlePrefix }}Iterator to stop iteration.
	Check({{ .TypeName }}) (bool, error)
}

// {{ .TitlePrefix }}Check is a shortcut implementation
// of {{ .TitlePrefix }}Checker based on a function.
type {{ .TitlePrefix }}Check func({{ .TypeName }}) (bool, error)

// Check checks an item type of {{ .TypeName }} for some condition.
// It returns EndOf{{ .TitlePrefix }}Iterator to stop iteration.
func (ch {{ .TitlePrefix }}Check) Check(item {{ .TypeName }}) (bool, error) { return ch(item) }

var (
	// Always{{ .TitlePrefix }}CheckTrue always returns true and empty error.
	Always{{ .TitlePrefix }}CheckTrue {{ .TitlePrefix }}Checker = {{ .TitlePrefix }}Check(
		func(item {{ .TypeName }}) (bool, error) { return true, nil })
	// Always{{ .TitlePrefix }}CheckFalse always returns false and empty error.
	Always{{ .TitlePrefix }}CheckFalse {{ .TitlePrefix }}Checker = {{ .TitlePrefix }}Check(
		func(item {{ .TypeName }}) (bool, error) { return false, nil })
)

// Not{{ .TitlePrefix }} do an inversion for checker result.
// It is returns Always{{ .TitlePrefix }}CheckTrue if checker is nil.
func Not{{ .TitlePrefix }}(checker {{ .TitlePrefix }}Checker) {{ .TitlePrefix }}Checker {
	if checker == nil {
		return Always{{ .TitlePrefix }}CheckTrue
	}
	return {{ .TitlePrefix }}Check(func(item {{ .TypeName }}) (bool, error) {
		yes, err := checker.Check(item)
		if err != nil {
			// No error wrapping since an error context is missing.
			return false, err
		}

		return !yes, nil
	})
}

type and{{ .TitlePrefix }} struct {
	lhs, rhs {{ .TitlePrefix }}Checker
}

func (a and{{ .TitlePrefix }}) Check(item {{ .TypeName }}) (bool, error) {
	isLHSPassed, err := a.lhs.Check(item)
	if err != nil {
		return false, wrapIfNotEndOf{{ .TitlePrefix }}Iterator(err, "lhs check")
	}
	if !isLHSPassed {
		return false, nil
	}

	isRHSPassed, err := a.rhs.Check(item)
	if err != nil {
		return false, wrapIfNotEndOf{{ .TitlePrefix }}Iterator(err, "rhs check")
	}
	return isRHSPassed, nil
}

// All{{ .TitlePrefix }} combines all the given checkers to one
// checking if all checkers return true.
// It returns true checker if the list of checkers is empty.
func All{{ .TitlePrefix }}(checkers ...{{ .TitlePrefix }}Checker) {{ .TitlePrefix }}Checker {
	var all = Always{{ .TitlePrefix }}CheckTrue
	for i := len(checkers) - 1; i >= 0; i-- {
		if checkers[i] == nil {
			continue
		}
		all = and{{ .TitlePrefix }}{checkers[i], all}
	}
	return all
}

type or{{ .TitlePrefix }} struct {
	lhs, rhs {{ .TitlePrefix }}Checker
}

func (o or{{ .TitlePrefix }}) Check(item {{ .TypeName }}) (bool, error) {
	isLHSPassed, err := o.lhs.Check(item)
	if err != nil {
		return false, wrapIfNotEndOf{{ .TitlePrefix }}Iterator(err, "lhs check")
	}
	if isLHSPassed {
		return true, nil
	}

	isRHSPassed, err := o.rhs.Check(item)
	if err != nil {
		return false, wrapIfNotEndOf{{ .TitlePrefix }}Iterator(err, "rhs check")
	}
	return isRHSPassed, nil
}

// Any{{ .TitlePrefix }} combines all the given checkers to one.
// checking if any checker return true.
// It returns false if the list of checkers is empty.
func Any{{ .TitlePrefix }}(checkers ...{{ .TitlePrefix }}Checker) {{ .TitlePrefix }}Checker {
	var any = Always{{ .TitlePrefix }}CheckFalse
	for i := len(checkers) - 1; i >= 0; i-- {
		if checkers[i] == nil {
			continue
		}
		any = or{{ .TitlePrefix }}{checkers[i], any}
	}
	return any
}

// Filtering{{ .TitlePrefix }}Iterator does iteration with
// filtering by previously set checker.
type Filtering{{ .TitlePrefix }}Iterator struct {
	prepared{{ .TitlePrefix }}Item
	filter {{ .TitlePrefix }}Checker
}

// HasNext checks if there is the next item
// in the iterator. HasNext is idempotent.
func (it *Filtering{{ .TitlePrefix }}Iterator) HasNext() bool {
	if it.hasNext {
		return true
	}
	for it.prepared{{ .TitlePrefix }}Item.HasNext() {
		next := it.base.Next()
		isFilterPassed, err := it.filter.Check(next)
		if err != nil {
			if !isEndOf{{ .TitlePrefix }}Iterator(err) {
				err = errors.Wrap(err, "filtering iterator: check")
			}
			it.err = err
			return false
		}

		if !isFilterPassed {
			continue
		}

		it.hasNext = true
		it.next = next
		return true
	}

	return false
}

// {{ .TitlePrefix }}Filtering sets filter while iterating over items.
// If filters is empty, so all items will return.
func {{ .TitlePrefix }}Filtering(items {{ .TitlePrefix }}Iterator, filters ...{{ .TitlePrefix }}Checker) {{ .TitlePrefix }}Iterator {
	if items == nil {
		return Empty{{ .TitlePrefix }}Iterator
	}
	return &Filtering{{ .TitlePrefix }}Iterator{prepared{{ .TitlePrefix }}Item{base: items}, All{{ .TitlePrefix }}(filters...)}
}

// DoingUntil{{ .TitlePrefix }}Iterator does iteration
// until previously set checker is passed.
type DoingUntil{{ .TitlePrefix }}Iterator struct {
	prepared{{ .TitlePrefix }}Item
	until {{ .TitlePrefix }}Checker
}

// HasNext checks if there is the next item
// in the iterator. HasNext is idempotent.
func (it *DoingUntil{{ .TitlePrefix }}Iterator) HasNext() bool {
	if it.hasNext {
		return true
	}
	for it.prepared{{ .TitlePrefix }}Item.HasNext() {
		next := it.base.Next()
		isUntilPassed, err := it.until.Check(next)
		if err != nil {
			if !isEndOf{{ .TitlePrefix }}Iterator(err) {
				err = errors.Wrap(err, "doing until iterator: until")
			}
			it.err = err
			return false
		}

		if isUntilPassed {
			it.err = EndOf{{ .TitlePrefix }}Iterator
		}

		it.hasNext = true
		it.next = next
		return true
	}

	return false
}

// {{ .TitlePrefix }}DoingUntil sets until checker while iterating over items.
// If untilList is empty, so all items returned as is.
func {{ .TitlePrefix }}DoingUntil(items {{ .TitlePrefix }}Iterator, untilList ...{{ .TitlePrefix }}Checker) {{ .TitlePrefix }}Iterator {
	if items == nil {
		return Empty{{ .TitlePrefix }}Iterator
	}
	var until {{ .TitlePrefix }}Checker
	if len(untilList) > 0 {
		until = All{{ .TitlePrefix }}(untilList...)
	} else {
		until = Always{{ .TitlePrefix }}CheckFalse
	}
	return &DoingUntil{{ .TitlePrefix }}Iterator{prepared{{ .TitlePrefix }}Item{base: items}, until}
}

// {{ .TitlePrefix }}SkipUntil sets until conditions to skip few items.
func {{ .TitlePrefix }}SkipUntil(items {{ .TitlePrefix }}Iterator, untilList ...{{ .TitlePrefix }}Checker) error {
	// no error wrapping since no additional context for the error; just return it.
	return {{ .TitlePrefix }}Discard({{ .TitlePrefix }}DoingUntil(items, untilList...))
}

// {{ .TitlePrefix }}EnumChecker is an object checking an item type of {{ .TypeName }}
// and its ordering number in for some condition.
type {{ .TitlePrefix }}EnumChecker interface {
	// Check checks an item type of {{ .TypeName }} and its ordering number for some condition.
	// It is suggested to return EndOf{{ .TitlePrefix }}Iterator to stop iteration.
	Check(int, {{ .TypeName }}) (bool, error)
}

// {{ .TitlePrefix }}EnumCheck is a shortcut implementation
// of {{ .TitlePrefix }}EnumChecker based on a function.
type {{ .TitlePrefix }}EnumCheck func(int, {{ .TypeName }}) (bool, error)

// Check checks an item type of {{ .TypeName }} and its ordering number for some condition.
// It returns EndOf{{ .TitlePrefix }}Iterator to stop iteration.
func (ch {{ .TitlePrefix }}EnumCheck) Check(n int, item {{ .TypeName }}) (bool, error) { return ch(n, item) }

type enumFrom{{ .TitlePrefix }}Checker struct {
	{{ .TitlePrefix }}Checker
}

func (ch enumFrom{{ .TitlePrefix }}Checker) Check(_ int, item {{ .TypeName }}) (bool, error) {
	return ch.{{ .TitlePrefix }}Checker.Check(item)
}

// EnumFrom{{ .TitlePrefix }}Checker adapts checker type of {{ .TitlePrefix }}Checker
// to the interface {{ .TitlePrefix }}EnumChecker.
// If checker is nil it is return based on Always{{ .TitlePrefix }}CheckFalse enum checker.
func EnumFrom{{ .TitlePrefix }}Checker(checker {{ .TitlePrefix }}Checker) {{ .TitlePrefix }}EnumChecker {
	if checker == nil {
		checker = Always{{ .TitlePrefix }}CheckFalse
	}
	return &enumFrom{{ .TitlePrefix }}Checker{checker}
}

var (
	// Always{{ .TitlePrefix }}EnumCheckTrue always returns true and empty error.
	Always{{ .TitlePrefix }}EnumCheckTrue = EnumFrom{{ .TitlePrefix }}Checker(
		Always{{ .TitlePrefix }}CheckTrue)
	// Always{{ .TitlePrefix }}EnumCheckFalse always returns false and empty error.
	Always{{ .TitlePrefix }}EnumCheckFalse = EnumFrom{{ .TitlePrefix }}Checker(
		Always{{ .TitlePrefix }}CheckFalse)
)

// EnumNot{{ .TitlePrefix }} do an inversion for checker result.
// It is returns Always{{ .TitlePrefix }}EnumCheckTrue if checker is nil.
func EnumNot{{ .TitlePrefix }}(checker {{ .TitlePrefix }}EnumChecker) {{ .TitlePrefix }}EnumChecker {
	if checker == nil {
		return Always{{ .TitlePrefix }}EnumCheckTrue
	}
	return {{ .TitlePrefix }}EnumCheck(func(n int, item {{ .TypeName }}) (bool, error) {
		yes, err := checker.Check(n, item)
		if err != nil {
			// No error wrapping since an error context is missing.
			return false, err
		}

		return !yes, nil
	})
}

type enumAnd{{ .TitlePrefix }} struct {
	lhs, rhs {{ .TitlePrefix }}EnumChecker
}

func (a enumAnd{{ .TitlePrefix }}) Check(n int, item {{ .TypeName }}) (bool, error) {
	isLHSPassed, err := a.lhs.Check(n, item)
	if err != nil {
		return false, wrapIfNotEndOf{{ .TitlePrefix }}Iterator(err, "lhs check")
	}
	if !isLHSPassed {
		return false, nil
	}

	isRHSPassed, err := a.rhs.Check(n, item)
	if err != nil {
		return false, wrapIfNotEndOf{{ .TitlePrefix }}Iterator(err, "rhs check")
	}
	return isRHSPassed, nil
}

// EnumAll{{ .TitlePrefix }} combines all the given checkers to one
// checking if all checkers return true.
// It returns true if the list of checkers is empty.
func EnumAll{{ .TitlePrefix }}(checkers ...{{ .TitlePrefix }}EnumChecker) {{ .TitlePrefix }}EnumChecker {
	var all = Always{{ .TitlePrefix }}EnumCheckTrue
	for i := len(checkers) - 1; i >= 0; i-- {
		if checkers[i] == nil {
			continue
		}
		all = enumAnd{{ .TitlePrefix }}{checkers[i], all}
	}
	return all
}

type enumOr{{ .TitlePrefix }} struct {
	lhs, rhs {{ .TitlePrefix }}EnumChecker
}

func (o enumOr{{ .TitlePrefix }}) Check(n int, item {{ .TypeName }}) (bool, error) {
	isLHSPassed, err := o.lhs.Check(n, item)
	if err != nil {
		return false, wrapIfNotEndOf{{ .TitlePrefix }}Iterator(err, "lhs check")
	}
	if isLHSPassed {
		return true, nil
	}

	isRHSPassed, err := o.rhs.Check(n, item)
	if err != nil {
		return false, wrapIfNotEndOf{{ .TitlePrefix }}Iterator(err, "rhs check")
	}
	return isRHSPassed, nil
}

// EnumAny{{ .TitlePrefix }} combines all the given checkers to one.
// checking if any checker return true.
// It returns false if the list of checkers is empty.
func EnumAny{{ .TitlePrefix }}(checkers ...{{ .TitlePrefix }}EnumChecker) {{ .TitlePrefix }}EnumChecker {
	var any = Always{{ .TitlePrefix }}EnumCheckFalse
	for i := len(checkers) - 1; i >= 0; i-- {
		if checkers[i] == nil {
			continue
		}
		any = enumOr{{ .TitlePrefix }}{checkers[i], any}
	}
	return any
}

// EnumFiltering{{ .TitlePrefix }}Iterator does iteration with
// filtering by previously set checker.
type EnumFiltering{{ .TitlePrefix }}Iterator struct {
	prepared{{ .TitlePrefix }}Item
	filter {{ .TitlePrefix }}EnumChecker
	count  int
}

// HasNext checks if there is the next item
// in the iterator. HasNext is idempotent.
func (it *EnumFiltering{{ .TitlePrefix }}Iterator) HasNext() bool {
	if it.hasNext {
		return true
	}
	for it.prepared{{ .TitlePrefix }}Item.HasNext() {
		next := it.base.Next()
		isFilterPassed, err := it.filter.Check(it.count, next)
		if err != nil {
			if !isEndOf{{ .TitlePrefix }}Iterator(err) {
				err = errors.Wrap(err, "enum filtering iterator: check")
			}
			it.err = err
			return false
		}
		it.count++

		if !isFilterPassed {
			continue
		}

		it.hasNext = true
		it.next = next
		return true
	}

	return false
}

// {{ .TitlePrefix }}EnumFiltering sets filter while iterating over items and their serial numbers.
// If filters is empty, so all items will return.
func {{ .TitlePrefix }}EnumFiltering(items {{ .TitlePrefix }}Iterator, filters ...{{ .TitlePrefix }}EnumChecker) {{ .TitlePrefix }}Iterator {
	if items == nil {
		return Empty{{ .TitlePrefix }}Iterator
	}
	return &EnumFiltering{{ .TitlePrefix }}Iterator{prepared{{ .TitlePrefix }}Item{base: items}, EnumAll{{ .TitlePrefix }}(filters...), 0}
}

// EnumDoingUntil{{ .TitlePrefix }}Iterator does iteration
// until previously set checker is passed.
type EnumDoingUntil{{ .TitlePrefix }}Iterator struct {
	prepared{{ .TitlePrefix }}Item
	until {{ .TitlePrefix }}EnumChecker
	count int
}

// HasNext checks if there is the next item
// in the iterator. HasNext is idempotent.
func (it *EnumDoingUntil{{ .TitlePrefix }}Iterator) HasNext() bool {
	if it.hasNext {
		return true
	}
	for it.prepared{{ .TitlePrefix }}Item.HasNext() {
		next := it.base.Next()
		isUntilPassed, err := it.until.Check(it.count, next)
		if err != nil {
			if !isEndOf{{ .TitlePrefix }}Iterator(err) {
				err = errors.Wrap(err, "doing until iterator: until")
			}
			it.err = err
			return false
		}
		it.count++

		if isUntilPassed {
			it.err = EndOf{{ .TitlePrefix }}Iterator
		}

		it.hasNext = true
		it.next = next
		return true
	}

	return false
}

// {{ .TitlePrefix }}EnumDoingUntil sets until checker while iterating over items.
// If untilList is empty, so all items returned as is.
func {{ .TitlePrefix }}EnumDoingUntil(items {{ .TitlePrefix }}Iterator, untilList ...{{ .TitlePrefix }}EnumChecker) {{ .TitlePrefix }}Iterator {
	if items == nil {
		return Empty{{ .TitlePrefix }}Iterator
	}
	var until {{ .TitlePrefix }}EnumChecker
	if len(untilList) > 0 {
		until = EnumAll{{ .TitlePrefix }}(untilList...)
	} else {
		until = Always{{ .TitlePrefix }}EnumCheckFalse
	}
	return &EnumDoingUntil{{ .TitlePrefix }}Iterator{prepared{{ .TitlePrefix }}Item{base: items}, until, 0}
}

// {{ .TitlePrefix }}EnumSkipUntil sets until conditions to skip few items.
func {{ .TitlePrefix }}EnumSkipUntil(items {{ .TitlePrefix }}Iterator, untilList ...{{ .TitlePrefix }}EnumChecker) error {
	// no error wrapping since no additional context for the error; just return it.
	return {{ .TitlePrefix }}Discard({{ .TitlePrefix }}EnumDoingUntil(items, untilList...))
}

// {{ .TitlePrefix }}GettingBatch returns the next batch from items.
func {{ .TitlePrefix }}GettingBatch(items {{ .TitlePrefix }}Iterator, batchSize int) {{ .TitlePrefix }}Iterator {
	if items == nil {
		return Empty{{ .TitlePrefix }}Iterator
	}
	if batchSize == 0 {
		return items
	}

	return {{ .TitlePrefix }}EnumDoingUntil(items, {{ .TitlePrefix }}EnumCheck(func(n int, item {{ .TypeName }}) (bool, error) {
		return n == batchSize-1, nil
	}))
}
