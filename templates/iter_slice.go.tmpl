// Code generated by github.com/soven/go-iterate. DO NOT EDIT.
package {{ .PackageName }}

// {{ .TitlePrefix }}SliceIterator is an iterator based on a slice of {{ .TypeName }}.
type {{ .TitlePrefix }}SliceIterator struct {
	slice []{{ .TypeName }}
	cur   int
}

// NewShowtime{{ .TitlePrefix }}SliceIterator returns a new instance of {{ .TitlePrefix }}SliceIterator.
// Note: any changes in slice will affect correspond items in the iterator.
// Use {{ .TitlePrefix }}Unroll(slice).MakeIter() instead of to iterate over copies of item in the items.
func NewShowtime{{ .TitlePrefix }}SliceIterator(slice []{{ .TypeName }}) *{{ .TitlePrefix }}SliceIterator {
	it := &{{ .TitlePrefix }}SliceIterator{slice: slice}
	return it
}

// HasNext checks if there is the next item
// in the iterator. HasNext is idempotent.
func (it {{ .TitlePrefix }}SliceIterator) HasNext() bool {
	return it.cur < len(it.slice)
}

// Next returns next item in the iterator.
// It should be invoked after check HasNext.
func (it *{{ .TitlePrefix }}SliceIterator) Next() {{ .TypeName }} {
	if it.cur >= len(it.slice) {
		panic("iterator next: pointer out of range")
	}

	item := it.slice[it.cur]
	it.cur++
	return item
}

// Err contains first met error while Next.
func ({{ .TitlePrefix }}SliceIterator) Err() error { return nil }

// {{ .TitlePrefix }}SliceIterator is an iterator based on a slice of {{ .TypeName }}
// and doing iteration in back direction.
type Inverting{{ .TitlePrefix }}SliceIterator struct {
	slice []{{ .TypeName }}
	cur   int
}

// NewInvertingShowtime{{ .TitlePrefix }}SliceIterator returns a new instance of Inverting{{ .TitlePrefix }}SliceIterator.
// Note: any changes in slice will affect correspond items in the iterator.
// Use Inverting{{ .TitlePrefix }}Slice({{ .TitlePrefix }}Unroll(slice)).MakeIter() instead of to iterate over copies of item in the items.
func NewInvertingShowtime{{ .TitlePrefix }}SliceIterator(slice []{{ .TypeName }}) *Inverting{{ .TitlePrefix }}SliceIterator {
	it := &Inverting{{ .TitlePrefix }}SliceIterator{slice: slice, cur: len(slice) - 1}
	return it
}

// HasNext checks if there is the next item
// in the iterator. HasNext is idempotent.
func (it Inverting{{ .TitlePrefix }}SliceIterator) HasNext() bool {
	return it.cur >= 0
}

// Next returns next item in the iterator.
// It should be invoked after check HasNext.
func (it *Inverting{{ .TitlePrefix }}SliceIterator) Next() {{ .TypeName }} {
	if it.cur < 0 {
		panic("iterator next: pointer out of range")
	}

	item := it.slice[it.cur]
	it.cur--
	return item
}

// Err contains first met error while Next.
func (Inverting{{ .TitlePrefix }}SliceIterator) Err() error { return nil }

// {{ .TitlePrefix }}Unroll unrolls items ot slice of {{ .TypeName }}.
func {{ .TitlePrefix }}Unroll(items {{ .TitlePrefix }}Iterator) {{ .TitlePrefix }}Slice {
	var slice {{ .TitlePrefix }}Slice
	panicIf{{ .TitlePrefix }}IteratorError({{ .TitlePrefix }}Discard({{ .TitlePrefix }}Handling(items, {{ .TitlePrefix }}Handle(func(item {{ .TypeName }}) error {
		slice = append(slice, item)
		return nil
	}))), "unroll: discard")

	return slice
}

// {{ .TitlePrefix }}Slice is a slice of {{ .TypeName }}.
type {{ .TitlePrefix }}Slice []{{ .TypeName }}

// MakeIter returns a new instance of {{ .TitlePrefix }}Iterator to iterate over it.
// It returns Empty{{ .TitlePrefix }}Iterator if the error is not nil.
func (s {{ .TitlePrefix }}Slice) MakeIter() {{ .TitlePrefix }}Iterator {
	return NewShowtime{{ .TitlePrefix }}SliceIterator(s)
}

// {{ .TitlePrefix }}Slice is a slice of {{ .TypeName }} which can make inverting iterator.
type Inverting{{ .TitlePrefix }}Slice []{{ .TypeName }}

// MakeIter returns a new instance of {{ .TitlePrefix }}Iterator to iterate over it.
// It returns Empty{{ .TitlePrefix }}Iterator if the error is not nil.
func (s Inverting{{ .TitlePrefix }}Slice) MakeIter() {{ .TitlePrefix }}Iterator {
	return NewInvertingShowtime{{ .TitlePrefix }}SliceIterator(s)
}

// {{ .TitlePrefix }}Invert unrolls items and make inverting iterator based on them.
func {{ .TitlePrefix }}Invert(items {{ .TitlePrefix }}Iterator) {{ .TitlePrefix }}Iterator {
	return Inverting{{ .TitlePrefix }}Slice({{ .TitlePrefix }}Unroll(items)).MakeIter()
}
