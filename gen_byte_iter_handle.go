// Code generated by github.com/soven/go-iterate. DO NOT EDIT.
package iter

import "github.com/pkg/errors"

type ByteHandler interface {
	// It is suggested to return EndOfByteIterator to stop iteration.
	Handle(byte) error
}

type ByteHandle func(byte) error

func (h ByteHandle) Handle(item byte) error { return h(item) }

var ByteDoNothing = ByteHandle(func(_ byte) error { return nil })

type doubleByteHandler struct {
	lhs, rhs ByteHandler
}

func (h doubleByteHandler) Handle(item byte) error {
	err := h.lhs.Handle(item)
	if err != nil {
		return errors.Wrap(err, "handle lhs")
	}
	err = h.rhs.Handle(item)
	if err != nil {
		return errors.Wrap(err, "handle rhs")
	}
	return nil
}

func ByteHandlerSeries(handlers ...ByteHandler) ByteHandler {
	var series ByteHandler = ByteDoNothing
	for i := len(handlers) - 1; i >= 0; i-- {
		if handlers[i] == nil {
			continue
		}
		series = doubleByteHandler{lhs: handlers[i], rhs: series}
	}
	return series
}

type HandlingByteIterator struct {
	preparedByteItem
	handler ByteHandler
}

func (it *HandlingByteIterator) HasNext() bool {
	if it.hasNext {
		return true
	}
	if it.preparedByteItem.HasNext() {
		next := it.base.Next()
		err := it.handler.Handle(next)
		if err != nil {
			if !isEndOfByteIterator(err) {
				err = errors.Wrap(err, "handling iterator: check")
			}
			it.err = err
			return false
		}

		it.hasNext = true
		it.next = next
		return true
	}

	return false
}

// ByteHandling sets handler while iterating over items.
// If handlers is empty, so it will do nothing.
func ByteHandling(items ByteIterator, handlers ...ByteHandler) ByteIterator {
	if items == nil {
		return EmptyByteIterator
	}
	return &HandlingByteIterator{preparedByteItem{base: items}, ByteHandlerSeries(handlers...)}
}

func ByteRange(items ByteIterator, handler ...ByteHandler) error {
	// no error wrapping since no additional context for the error; just return it.
	return ByteDiscard(ByteHandling(items, handler...))
}

type ByteEnumHandler interface {
	// It is suggested to return EndOfByteIterator to stop iteration.
	Handle(int, byte) error
}

type ByteEnumHandle func(int, byte) error

func (h ByteEnumHandle) Handle(n int, item byte) error { return h(n, item) }

var ByteDoEnumNothing = ByteEnumHandle(func(_ int, _ byte) error { return nil })

type doubleByteEnumHandler struct {
	lhs, rhs ByteEnumHandler
}

func (h doubleByteEnumHandler) Handle(n int, item byte) error {
	err := h.lhs.Handle(n, item)
	if err != nil {
		return errors.Wrap(err, "handle lhs")
	}
	err = h.rhs.Handle(n, item)
	if err != nil {
		return errors.Wrap(err, "handle rhs")
	}
	return nil
}

func ByteEnumHandlerSeries(handlers ...ByteEnumHandler) ByteEnumHandler {
	var series ByteEnumHandler = ByteDoEnumNothing
	for i := len(handlers) - 1; i >= 0; i-- {
		if handlers[i] == nil {
			continue
		}
		series = doubleByteEnumHandler{lhs: handlers[i], rhs: series}
	}
	return series
}

type EnumHandlingByteIterator struct {
	preparedByteItem
	handler ByteEnumHandler
	count   int
}

func (it *EnumHandlingByteIterator) HasNext() bool {
	if it.hasNext {
		return true
	}
	if it.preparedByteItem.HasNext() {
		next := it.base.Next()
		err := it.handler.Handle(it.count, next)
		if err != nil {
			if !isEndOfByteIterator(err) {
				err = errors.Wrap(err, "enum handling iterator: check")
			}
			it.err = err
			return false
		}
		it.count++

		it.hasNext = true
		it.next = next
		return true
	}

	return false
}

// ByteEnumHandling sets handler while iterating over items with their serial number.
// If handlers is empty, so it will do nothing.
func ByteEnumHandling(items ByteIterator, handlers ...ByteEnumHandler) ByteIterator {
	if items == nil {
		return EmptyByteIterator
	}
	return &EnumHandlingByteIterator{
		preparedByteItem{base: items}, ByteEnumHandlerSeries(handlers...), 0}
}

func ByteEnumerate(items ByteIterator, handler ...ByteEnumHandler) error {
	// no error wrapping since no additional context for the error; just return it.
	return ByteDiscard(ByteEnumHandling(items, handler...))
}
