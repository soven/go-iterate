// Code generated by github.com/soven/go-iterate. DO NOT EDIT.
package iter

type UintSliceIterator struct {
	slice []uint
	cur   int
}

// NewShowtimeUintSliceIterator returns a new instance of UintSliceIterator.
// Note: any changes in slice will affect correspond items in the iterator.
// Use UintUnroll(slice).MakeIter() instead of to iterate over copies of item in the items.
func NewShowtimeUintSliceIterator(slice []uint) *UintSliceIterator {
	it := &UintSliceIterator{slice: slice}
	return it
}

func (it UintSliceIterator) HasNext() bool {
	return it.cur < len(it.slice)
}

func (it *UintSliceIterator) Next() uint {
	if it.cur >= len(it.slice) {
		panic("iterator next: pointer out of range")
	}

	item := it.slice[it.cur]
	it.cur++
	return item
}

func (UintSliceIterator) Err() error { return nil }

type InvertingUintSliceIterator struct {
	slice []uint
	cur   int
}

// NewInvertingShowtimeUintSliceIterator returns a new instance of InvertingUintSliceIterator.
// Note: any changes in slice will affect correspond items in the iterator.
// Use InvertingUintSlice(UintUnroll(slice)).MakeIter() instead of to iterate over copies of item in the items.
func NewInvertingShowtimeUintSliceIterator(slice []uint) *InvertingUintSliceIterator {
	it := &InvertingUintSliceIterator{slice: slice, cur: len(slice) - 1}
	return it
}

func (it InvertingUintSliceIterator) HasNext() bool {
	return it.cur >= 0
}

func (it *InvertingUintSliceIterator) Next() uint {
	if it.cur < 0 {
		panic("iterator next: pointer out of range")
	}

	item := it.slice[it.cur]
	it.cur--
	return item
}

func (InvertingUintSliceIterator) Err() error { return nil }

func UintUnroll(items UintIterator) UintSlice {
	var slice UintSlice
	panicIfUintIteratorError(UintRange(items, UintHandle(func(item uint) error {
		slice = append(slice, item)
		return nil
	})), "unroll: discard")

	return slice
}

type UintSlice []uint

func (s UintSlice) MakeIter() (UintIterator, error) {
	return NewShowtimeUintSliceIterator(s), nil
}

func MakeUintSliceIter(slice []uint) UintIterator {
	items, err := UintSlice(slice).MakeIter()
	panicIfUintIteratorError(err, "make slice iter")
	return items
}

type InvertingUintSlice []uint

func (s InvertingUintSlice) MakeIter() (UintIterator, error) {
	return NewInvertingShowtimeUintSliceIterator(s), nil
}

func MakeInvertingUintSliceIter(slice []uint) UintIterator {
	items, err := InvertingUintSlice(slice).MakeIter()
	panicIfUintIteratorError(err, "make inverting slice iter")
	return items
}

func UintInvert(items UintIterator) UintIterator {
	return MakeInvertingUintSliceIter(UintUnroll(items))
}
