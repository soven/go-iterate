// Code generated by github.com/soven/go-iterate. DO NOT EDIT.
package iter

import "github.com/pkg/errors"

type Uint32Checker interface {
	// It is suggested to return EndOfUint32Iterator to stop iteration.
	Check(uint32) (bool, error)
}

type Uint32Check func(uint32) (bool, error)

func (ch Uint32Check) Check(item uint32) (bool, error) { return ch(item) }

var (
	AlwaysUint32CheckTrue  = Uint32Check(func(item uint32) (bool, error) { return true, nil })
	AlwaysUint32CheckFalse = Uint32Check(func(item uint32) (bool, error) { return false, nil })
)

func NotUint32(checker Uint32Checker) Uint32Checker {
	if checker == nil {
		return AlwaysUint32CheckTrue
	}
	return Uint32Check(func(item uint32) (bool, error) {
		yes, err := checker.Check(item)
		if err != nil {
			// No error wrapping since an error context is missing.
			return false, err
		}

		return !yes, nil
	})
}

type andUint32 struct {
	lhs, rhs Uint32Checker
}

func (a andUint32) Check(item uint32) (bool, error) {
	isLHSPassed, err := a.lhs.Check(item)
	if err != nil {
		return false, wrapIfNotEndOfUint32Iterator(err, "lhs check")
	}
	if !isLHSPassed {
		return false, nil
	}

	isRHSPassed, err := a.rhs.Check(item)
	if err != nil {
		return false, wrapIfNotEndOfUint32Iterator(err, "rhs check")
	}
	return isRHSPassed, nil
}

func AllUint32(checkers ...Uint32Checker) Uint32Checker {
	var all Uint32Checker = AlwaysUint32CheckTrue
	for i := len(checkers) - 1; i >= 0; i-- {
		if checkers[i] == nil {
			continue
		}
		all = andUint32{checkers[i], all}
	}
	return all
}

type orUint32 struct {
	lhs, rhs Uint32Checker
}

func (o orUint32) Check(item uint32) (bool, error) {
	isLHSPassed, err := o.lhs.Check(item)
	if err != nil {
		return false, wrapIfNotEndOfUint32Iterator(err, "lhs check")
	}
	if isLHSPassed {
		return true, nil
	}

	isRHSPassed, err := o.rhs.Check(item)
	if err != nil {
		return false, wrapIfNotEndOfUint32Iterator(err, "rhs check")
	}
	return isRHSPassed, nil
}

func AnyUint32(checkers ...Uint32Checker) Uint32Checker {
	var any Uint32Checker = AlwaysUint32CheckFalse
	for i := len(checkers) - 1; i >= 0; i-- {
		if checkers[i] == nil {
			continue
		}
		any = orUint32{checkers[i], any}
	}
	return any
}

type FilteringUint32Iterator struct {
	preparedUint32Item
	filter Uint32Checker
}

func (it *FilteringUint32Iterator) HasNext() bool {
	if it.hasNext {
		return true
	}
	for it.preparedUint32Item.HasNext() {
		next := it.base.Next()
		isFilterPassed, err := it.filter.Check(next)
		if err != nil {
			if !isEndOfUint32Iterator(err) {
				err = errors.Wrap(err, "filtering iterator: check")
			}
			it.err = err
			return false
		}

		if !isFilterPassed {
			continue
		}

		it.hasNext = true
		it.next = next
		return true
	}

	return false
}

// Uint32Filtering sets filter while iterating over items.
// If filters is empty, so all items will return.
func Uint32Filtering(items Uint32Iterator, filters ...Uint32Checker) Uint32Iterator {
	if items == nil {
		return EmptyUint32Iterator
	}
	return &FilteringUint32Iterator{preparedUint32Item{base: items}, AllUint32(filters...)}
}

func Uint32Filter(items Uint32Iterator, checker ...Uint32Checker) error {
	// no error wrapping since no additional context for the error; just return it.
	return Uint32Discard(Uint32Filtering(items, checker...))
}

type Uint32EnumChecker interface {
	// It is suggested to return EndOfUint32Iterator to stop iteration.
	Check(int, uint32) (bool, error)
}

type Uint32EnumCheck func(int, uint32) (bool, error)

func (ch Uint32EnumCheck) Check(n int, item uint32) (bool, error) { return ch(n, item) }

type enumFromUint32Checker struct {
	Uint32Checker
}

func (ch enumFromUint32Checker) Check(_ int, item uint32) (bool, error) {
	return ch.Uint32Checker.Check(item)
}

func EnumFromUint32Checker(checker Uint32Checker) Uint32EnumChecker {
	return &enumFromUint32Checker{checker}
}

var (
	AlwaysUint32EnumCheckTrue  = EnumFromUint32Checker(AlwaysUint32CheckTrue)
	AlwaysUint32EnumCheckFalse = EnumFromUint32Checker(AlwaysUint32CheckFalse)
)

func EnumNotUint32(checker Uint32EnumChecker) Uint32EnumChecker {
	if checker == nil {
		return AlwaysUint32EnumCheckTrue
	}
	return Uint32EnumCheck(func(n int, item uint32) (bool, error) {
		yes, err := checker.Check(n, item)
		if err != nil {
			// No error wrapping since an error context is missing.
			return false, err
		}

		return !yes, nil
	})
}

type enumAndUint32 struct {
	lhs, rhs Uint32EnumChecker
}

func (a enumAndUint32) Check(n int, item uint32) (bool, error) {
	isLHSPassed, err := a.lhs.Check(n, item)
	if err != nil {
		return false, wrapIfNotEndOfUint32Iterator(err, "lhs check")
	}
	if !isLHSPassed {
		return false, nil
	}

	isRHSPassed, err := a.rhs.Check(n, item)
	if err != nil {
		return false, wrapIfNotEndOfUint32Iterator(err, "rhs check")
	}
	return isRHSPassed, nil
}

func EnumAllUint32(checkers ...Uint32EnumChecker) Uint32EnumChecker {
	var all Uint32EnumChecker = AlwaysUint32EnumCheckTrue
	for i := len(checkers) - 1; i >= 0; i-- {
		if checkers[i] == nil {
			continue
		}
		all = enumAndUint32{checkers[i], all}
	}
	return all
}

type enumOrUint32 struct {
	lhs, rhs Uint32EnumChecker
}

func (o enumOrUint32) Check(n int, item uint32) (bool, error) {
	isLHSPassed, err := o.lhs.Check(n, item)
	if err != nil {
		return false, wrapIfNotEndOfUint32Iterator(err, "lhs check")
	}
	if isLHSPassed {
		return true, nil
	}

	isRHSPassed, err := o.rhs.Check(n, item)
	if err != nil {
		return false, wrapIfNotEndOfUint32Iterator(err, "rhs check")
	}
	return isRHSPassed, nil
}

func EnumAnyUint32(checkers ...Uint32EnumChecker) Uint32EnumChecker {
	var any Uint32EnumChecker = AlwaysUint32EnumCheckFalse
	for i := len(checkers) - 1; i >= 0; i-- {
		if checkers[i] == nil {
			continue
		}
		any = enumOrUint32{checkers[i], any}
	}
	return any
}

type EnumFilteringUint32Iterator struct {
	preparedUint32Item
	filter Uint32EnumChecker
	count  int
}

func (it *EnumFilteringUint32Iterator) HasNext() bool {
	if it.hasNext {
		return true
	}
	for it.preparedUint32Item.HasNext() {
		next := it.base.Next()
		isFilterPassed, err := it.filter.Check(it.count, next)
		if err != nil {
			if !isEndOfUint32Iterator(err) {
				err = errors.Wrap(err, "enum filtering iterator: check")
			}
			it.err = err
			return false
		}
		it.count++

		if !isFilterPassed {
			continue
		}

		it.hasNext = true
		it.next = next
		return true
	}

	return false
}

// Uint32EnumFiltering sets filter while iterating over items and their serial numbers.
// If filters is empty, so all items will return.
func Uint32EnumFiltering(items Uint32Iterator, filters ...Uint32EnumChecker) Uint32Iterator {
	if items == nil {
		return EmptyUint32Iterator
	}
	return &EnumFilteringUint32Iterator{preparedUint32Item{base: items}, EnumAllUint32(filters...), 0}
}

type DoingUntilUint32Iterator struct {
	preparedUint32Item
	until Uint32Checker
}

func (it *DoingUntilUint32Iterator) HasNext() bool {
	if it.hasNext {
		return true
	}
	for it.preparedUint32Item.HasNext() {
		next := it.base.Next()
		isUntilPassed, err := it.until.Check(next)
		if err != nil {
			if !isEndOfUint32Iterator(err) {
				err = errors.Wrap(err, "doing until iterator: until")
			}
			it.err = err
			return false
		}

		if isUntilPassed {
			it.err = EndOfUint32Iterator
		}

		it.hasNext = true
		it.next = next
		return true
	}

	return false
}

// Uint32DoingUntil sets until checker while iterating over items.
// If untilList is empty, so all items returned as is.
func Uint32DoingUntil(items Uint32Iterator, untilList ...Uint32Checker) Uint32Iterator {
	if items == nil {
		return EmptyUint32Iterator
	}
	return &DoingUntilUint32Iterator{preparedUint32Item{base: items}, AllUint32(untilList...)}
}

func Uint32DoUntil(items Uint32Iterator, untilList ...Uint32Checker) error {
	// no error wrapping since no additional context for the error; just return it.
	return Uint32Discard(Uint32DoingUntil(items, untilList...))
}

// Uint32GettingBatch returns the next batch from items.
func Uint32GettingBatch(items Uint32Iterator, batchSize int) Uint32Iterator {
	if items == nil {
		return EmptyUint32Iterator
	}
	if batchSize == 0 {
		return items
	}

	size := 0
	return Uint32DoingUntil(items, Uint32Check(func(item uint32) (bool, error) {
		size++
		return size >= batchSize, nil
	}))
}
